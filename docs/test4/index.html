<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=lf.css rel=stylesheet> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,{}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.56c24277.js"}catch(e){main="/client/legacy/client.3dfb36a3.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <link href=client/client-a6ab5402.css rel=stylesheet> <link href=/client/client.56c24277.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-a6ab5402.css rel=preload as=style><link href=/client/test4.dd1d4804.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/Widget1.f03279fc.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/Widget2.a4b3b0f8.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/utils.932e656f.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js rel=modulepreload as=script crossorigin=use-credentials></head> <body> <div id=sapper> <main class=svelte-1vk44dp><div><h2>Test 4 (with components)</h2> <p>This page shows how code within a script element is run on the server and on the client in presence of several components. </p> <p>We see that the code of the script element of the current page is run then the components start loading and everything is interlaced. Indentation in the client column is mine to help understand the order of operations. Note that included components are completely loaded (that is no more code is run) before the including component (or page) is completely loaded. </p> <div class=border><p>I am <code>widget1</code> and here is widget2: <span>I am <code>widget2</code> called from widget1. </span></p> <span>I am <code>widget2</code> called from page. </span></div> <center><button><a href=test3>previous test</a></button> <button><a href=test5>next test</a></button></center> <table><tr><th>server<th>client</tr> <tr><td><pre>Test#4 - I am running on server.
Test#4 Widget#1 - I am running on server.
Test#4 Widget#2/widget1 - I am running on server.
Test#4 Widget#2/page - I am running on server.

  </pre></td> <td><pre>Test#4 - I am running on client. 
Test#4 - Running beforeUpdate on client 
  Test#4 Widget#1 - I am running on client.
  Test#4 Widget#1 - Running beforeUpdate on client 
    Test#4 Widget#2/widget1 - I am running on client. 
    Test#4 Widget#2/widget1 - Running beforeUpdate on client 
  Test#4 Widget#2/page - I am running on client. 
  Test#4 Widget#2/page - Running beforeUpdate on client 
    Test#4 Widget#2/widget1 - Running onMount on client 
    Test#4 Widget#2/widget1 - Running afterUpdate on client 
  Test#4 Widget#1 - Running onMount on client
  Test#4 Widget#1 - Running afterUpdate on client
  Test#4 Widget#2/page - Running onMount on client
  Test#4 Widget#2/page - Running afterUpdate on client
Test#4 - Running onMount on client 
Test#4 - Running afterUpdate on client

  </pre></table> <h2>Conclusion</h2> <p>The evaluation order is respected but if code and beforeUpdate are run in sequence, onMount and afterUpdate are run after the corresponding HTML is generated. </p> </div></main></div> 